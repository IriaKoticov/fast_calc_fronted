# LocalizationManager

## Назначение
Управляет текстовыми ресурсами интерфейса для разных локалей. Загружает строки из TOML-файлов, хранит их в памяти и предоставляет API для выбора языка, поиска перевода и автодетекта системной локали.

## Организация данных
- `locale_directory_` — корневая директория с локалью; может содержать как вложенные папки, так и одиночные `.toml` файлы.
- `current_locale_` — код текущей активной локали (например, `ru_RU`).
- `texts_` — плоский словарь `ключ → строка`, полученный из TOML-структуры при помощи рекурсивного развёртывания.

## Формат файлов локализации
- Каждая локаль размещается в отдельной папке (`locales/ru_RU/*.toml`) или одиночном файле (`locales/ru_RU.toml`).
- Переводы описываются в формате TOML, вложенные структуры преобразуются в плоские ключи через точку (`dialog.ok`, `menu.file.open` и т.д.).

## Жизненный цикл
1. Конструктор принимает путь к каталогу локалей, нормализует его через `to_path` и создаёт директорию, если её не было.
2. Вызов `load()` пытается:
   - определить системную локаль (если `current_locale_` ещё пуст);
   - загрузить соответствующий набор строк;
   - при неудаче перебирает все доступные локали, выбирая первую успешную.
3. Если подходящие файлы не найдены, `texts_` очищается.

## Публичные методы
- `bool load_locale(const string& locale_code)` — пытается загрузить конкретную локаль из файловой системы.
- `string get_text(const string& key, const string& default_text = "") const` — возвращает переведённую строку или `default_text`, если ключ не найден.
- `vector<string> available_locales() const` — перечисляет доступные локали, просматривая директории и `.toml` файлы.
- `bool detect_system_locale()` — ищет системный язык (через WinAPI, CoreFoundation или POSIX API) и выбирает лучшую подходящую локаль из доступных.
- `const string& current_locale() const` — быстрый доступ к выбранному коду локали.
- Унаследованные `load()`/`save()` используются для базовой интеграции с другими подсистемами.

## Особенности реализации
- Парсер TOML разворачивает таблицы и массивы в плоские ключи — это упрощает поиск строк и избавляет от необходимости хранить дерево.
- Вспомогательные функции нормализуют коды локалей (`ru-RU`, `ru_RU.UTF-8` → `ru_RU`) и позволяют сопоставить языки без суффикса страны.
- `available_locales()` возвращает список без дубликатов и отсортированный по алфавиту.
- Метод `save()` пока оставлен пустым — его можно расширить для пользовательских переводов.

## Как использовать
1. Создайте `LocalizationManager`, передав путь к каталогу локалей (можно относительный).
2. Вызовите `load()`, чтобы менеджер попытался выбрать подходящую локаль и загрузить тексты.
3. Получайте переводы через `get_text`, передавая ключи и опциональный текст по умолчанию.
4. Для ручного переключения вызовите `load_locale("en_US")` (или другой код); затем можно повторно вызвать `load()` для fallback-логики.

### Пример использования
```cpp
LocalizationManager l10n("resources/locales");
l10n.load(); // Попробует подобрать системную локаль

std::cout << l10n.get_text("app.title", "Fast Calc") << '\n';
std::cout << l10n.get_text("menu.file.open", "Open") << '\n';

if (!l10n.load_locale("en_US")) {
    std::cerr << "Locale en_US is missing\n";
}

std::cout << "Current locale: " << l10n.current_locale() << '\n';
```
> Если каталоги локалей ещё не подготовлены, `load()` не упадёт — список доступных локалей будет пуст, и все запросы вернут значения по умолчанию.

### Рекомендации по структуре каталогов
- Используйте ISO-коды (`en`, `en_US`, `ru`, `ru_RU`) для единообразия названий.
- Для крупных локалей можно разбить переводы по нескольким файлам внутри директории (`common.toml`, `dialogs.toml` и т.д.).
- Храните ключи в одном регистре (обычно `snake_case` или `dot.case`) — так проще сопоставлять их с кодом интерфейса.
