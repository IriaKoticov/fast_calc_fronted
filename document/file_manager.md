# FileManager

## Назначение
Базовый слой для всех менеджеров, работающих с файловой системой. Инкапсулирует преобразование путей, проверку существования, чтение и запись данных, а также создание и удаление каталогов.

## Основные обязанности
- Приведение строкового пути к `std::filesystem::path` через `to_path`, чтобы всегда работать с абсолютными путями.
- Безопасная работа с файловой системой: методы оборачивают операции в `try/catch`, возвращая аккуратные булевы значения или пустые строки при ошибках.
- Предоставление универсальных `load()` и `save()` интерфейсов для наследников, которым нужно хранить состояние на диске (например, в формате TOML).

## Ключевые методы
- `bool exists(const string& path) const` — проверяет, существует ли файл или каталог.
- `bool create_dir(const string& path) const` — создаёт директорию (включая родителей) и возвращает признак успеха.
- `bool remove(const string& path) const` — удаляет файл или каталог рекурсивно.
- `string read_file(const string& path) const` — читает весь файл в строку, поддерживая бинарный режим.
- `bool write_file(const string& path, const string& content) const` — записывает содержимое в файл, автоматически создавая родительские каталоги.

## Особенности реализации
- Все методы устойчивы к исключениям `std::filesystem::filesystem_error` — в случае ошибки возвращаются безопасные значения.
- `to_path` преобразует относительные пути в абсолютные, что упрощает работу наследников и помогает избежать зависимостей от текущего каталога процесса.

## Как использовать
Наследуйте `FileManager`, реализуйте `load()` и `save()`, а затем используйте готовые вспомогательные методы для работы с файлами. Примеры таких классов — `HistoryManager` и `ConfigManager`.

### Типичный сценарий
1. Получите или вычислите путь до данных (например, `~/.cache/app/state.json`).
2. Перед выполнением операций вызовите `create_dir` для родительской директории, если файл должен существовать.
3. Используйте `read_file` для загрузки содержимого и преобразуйте его в нужный формат (JSON/TOML/бинарный буфер).
4. После обновления данных сериализуйте их обратно и запишите через `write_file`.

### Пример наследника
```cpp
class StateManager : public FileManager {
public:
    explicit StateManager(const string& path) : path_(to_path(path).string()) {}

    void load() override {
        state_ = parse_json(read_file(path_));
    }

    void save() override {
        create_dir(std::filesystem::path(path_).parent_path().string());
        write_file(path_, dump_json(state_));
    }

private:
    string path_;
    State state_;
};
```
> Используйте `to_path` в конструкторе, чтобы сразу нормализовать путь и избежать зависимостей от текущего рабочего каталога.
